// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: sub_history.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const findSubHistory = `-- name: FindSubHistory :one
SELECT user_id, creator_id, activated_at, expires_at, status, price, sub_hist_id FROM sub_history
WHERE sub_hist_id = $1 LIMIT 1
`

func (q *Queries) FindSubHistory(ctx context.Context, subHistID int64) (*SubHistory, error) {
	row := q.db.QueryRowContext(ctx, findSubHistory, subHistID)
	var i SubHistory
	err := row.Scan(
		&i.UserID,
		&i.CreatorID,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.Price,
		&i.SubHistID,
	)
	return &i, err
}

const insertSubHistory = `-- name: InsertSubHistory :one
INSERT INTO sub_history (
       user_id,
       creator_id,
       activated_at,
       expires_at,
       status,
       price
) VALUES (
  $1, $2, $3, $4, $5, $6
) RETURNING user_id, creator_id, activated_at, expires_at, status, price, sub_hist_id
`

type InsertSubHistoryParams struct {
	UserID      int64         `db:"user_id"`
	CreatorID   int64         `db:"creator_id"`
	ActivatedAt time.Time     `db:"activated_at"`
	ExpiresAt   time.Time     `db:"expires_at"`
	Status      SubStatus     `db:"status"`
	Price       sql.NullInt32 `db:"price"`
}

func (q *Queries) InsertSubHistory(ctx context.Context, arg InsertSubHistoryParams) (*SubHistory, error) {
	row := q.db.QueryRowContext(ctx, insertSubHistory,
		arg.UserID,
		arg.CreatorID,
		arg.ActivatedAt,
		arg.ExpiresAt,
		arg.Status,
		arg.Price,
	)
	var i SubHistory
	err := row.Scan(
		&i.UserID,
		&i.CreatorID,
		&i.ActivatedAt,
		&i.ExpiresAt,
		&i.Status,
		&i.Price,
		&i.SubHistID,
	)
	return &i, err
}
